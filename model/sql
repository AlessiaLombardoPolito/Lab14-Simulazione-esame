1. SELECT
Il comando SELECT viene utilizzato per recuperare dati da un database.

-- Seleziona tutte le colonne dalla tabella 'employees'
SELECT * FROM employees;

-- Seleziona solo le colonne 'name' e 'salary' dalla tabella 'employees'
SELECT name, salary FROM employees;



2. WHERE
Il comando WHERE viene utilizzato per filtrare i record.

-- Seleziona tutti gli impiegati con un salario superiore a 50000
SELECT * FROM employees WHERE salary > 50000;

-- Seleziona gli impiegati con il nome 'John'
SELECT * FROM employees WHERE name = 'John';




3. JOIN
Il comando JOIN viene utilizzato per combinare righe da due o più tabelle.

-- Seleziona tutti gli impiegati e i loro dipartimenti utilizzando un INNER JOIN
SELECT employees.name, departments.department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;

-- Seleziona tutti gli impiegati e i loro dipartimenti, includendo impiegati senza dipartimento utilizzando un LEFT JOIN
SELECT employees.name, departments.department_name
FROM employees
LEFT JOIN departments ON employees.department_id = departments.id;




4. GROUP BY
Il comando GROUP BY viene utilizzato per raggruppare i risultati in base a una o più colonne.

-- Raggruppa gli impiegati per dipartimento e calcola il salario medio per ciascun dipartimento
SELECT department_id, AVG(salary) AS average_salary
FROM employees
GROUP BY department_id;




5. ORDER BY
Il comando ORDER BY viene utilizzato per ordinare i risultati.

-- Seleziona tutti gli impiegati ordinati per salario in ordine crescente
SELECT * FROM employees ORDER BY salary;

-- Seleziona tutti gli impiegati ordinati per salario in ordine decrescente
SELECT * FROM employees ORDER BY salary DESC;




6. HAVING
Il comando HAVING viene utilizzato per filtrare i gruppi creati con GROUP BY.

-- Raggruppa gli impiegati per dipartimento e mostra solo quelli con un salario medio superiore a 50000
SELECT department_id, AVG(salary) AS average_salary
FROM employees
GROUP BY department_id
HAVING AVG(salary) > 50000;




7. LIMIT
Il comando LIMIT viene utilizzato per specificare il numero di record da restituire.


-- Seleziona i primi 10 impiegati ordinati per salario
SELECT * FROM employees ORDER BY salary DESC LIMIT 10;



8. DISTINCT
Il comando DISTINCT viene utilizzato per restituire solo i valori distinti.

-- Seleziona tutti i dipartimenti distinti dalla tabella 'employees'
SELECT DISTINCT department_id FROM employees;




esempi:
"""select tmp.ID, tmp.IATA_CODE, count(*) as N
                    from (
                    SELECT a.ID , a.IATA_CODE , f.AIRLINE_ID, count(*) as n
                    FROM airports a , flights f
                    WHERE a.ID = f.ORIGIN_AIRPORT_ID or a.ID = f.DESTINATION_AIRPORT_ID
                    group by a.ID , a.IATA_CODE , f.AIRLINE_ID
                    ) as tmp
                    group by tmp.ID, tmp.IATA_CODE
                    having N >= %s"""
        """la query più interna:
        - Questa subquery seleziona gli aeroporti (airports a) e i voli (flights f) combinati dove l'ID dell'aeroporto
        corrisponde all'ID dell'aeroporto di partenza (ORIGIN_AIRPORT_ID) o di destinazione (DESTINATION_AIRPORT_ID)
        nel dataset dei voli.
        - Conta il numero di record (voli) per ciascuna combinazione di aeroporto, codice IATA e ID della compagnia aerea.
        - Raggruppa per a.ID (ID dell'aeroporto), a.IATA_CODE (codice IATA dell'aeroporto) e f.AIRLINE_ID (ID della
        compagnia aerea).
        - Ordina i risultati per a.ID e f.AIRLINE_ID.

        la query esterna:
        - La query esterna seleziona i risultati della subquery interna (alias tmp) e conta il numero di righe risultanti
        per ciascun ID e IATA_CODE.
        - Raggruppa per tmp.ID e tmp.IATA_CODE.
        - HAVING N >= 5 filtra i risultati per includere solo gli aeroporti che hanno almeno 5 record di voli
        (sia come origine che come destinazione)."""






        SELECT t.teamCode , t.ID , sum(s.salary) as totSalary
                      FROM salaries s , teams t , appearances a
                      WHERE s.`year` = t.`year` and t.`year` = a.`year`
                      and a.`year` = %s
                      and t.ID = a.teamID
                      and s.playerID = a.playerID
                      GROUP by t.teamCode"""
        #Questa query SQL è progettata per calcolare il totale degli stipendi per ciascuna squadra in un determinato
        # anno. Funzionamento Generale:
        #
        # La query seleziona i codici delle squadre (t.teamCode) e i loro ID (t.ID), insieme alla somma totale degli
        # stipendi dei loro giocatori (sum(s.salary)).
        # Le tabelle salaries, teams e appearances sono unite implicitamente utilizzando condizioni che assicurano
        # che i dati corrispondano per lo stesso anno e per le stesse squadre e giocatori.
        # Viene filtrato solo per l'anno specificato (%s), e i risultati sono raggruppati per codice della squadra.
        # Alla fine, la query restituisce il totale degli stipendi per ciascuna squadra nell'anno specificato.



        SELECT count(*)
                    FROM exhibition_objects eo1, exhibition_objects eo2
                    WHERE eo1.exhibition_id = eo2.exhibition_id
                    and eo1.object_id < eo2.object_id
                    and eo1.object_id = %s
                    and eo2.object_id = %s

         Questa query SQL effettua un conteggio delle righe dalla tabella exhibition_objects che soddisfano determinate
         condizioni. Ecco una spiegazione dettagliata delle varie parti della query:

SELECT count(*)
Questa parte della query conta il numero totale di righe che soddisfano le condizioni specificate nel WHERE clausola.

FROM exhibition_objects eo1, exhibition_objects eo2
Qui la query sta creando due alias (eo1 e eo2) per la tabella exhibition_objects. In pratica, la query sta eseguendo un
auto-join della tabella exhibition_objects con sé stessa.

WHERE eo1.exhibition_id = eo2.exhibition_id
Questa condizione impone che le righe delle due istanze della tabella exhibition_objects devono appartenere allo stesso
exhibition_id.

and eo1.object_id < eo2.object_id
Questa condizione impone che l'object_id di eo1 deve essere minore dell'object_id di eo2. Questo è usato per
assicurarsi che ogni coppia di oggetti venga contata una sola volta ed evitare di contare due volte la stessa coppia
in ordine inverso.







                SELECT eo1.object_id as o1, eo2.object_id as o2, count(*) as peso
                    FROM exhibition_objects eo1, exhibition_objects eo2
                    WHERE eo1.exhibition_id = eo2.exhibition_id
                    and eo1.object_id < eo2.object_id
                    group by eo1.object_id, eo2.object_id
                    order by peso desc

Questa query SQL esegue un conteggio delle coppie di oggetti che compaiono insieme nelle stesse esibizioni, restituendo
il numero di volte in cui ciascuna coppia appare insieme. Ecco una spiegazione dettagliata delle varie parti della query:

SELECT eo1.object_id as o1, eo2.object_id as o2, count(*) as peso
Questa parte della query seleziona tre colonne: eo1.object_id, eo2.object_id, e il conteggio delle righe che soddisfano
le condizioni specificate nel WHERE clausola. eo1.object_id viene rinominato come o1, eo2.object_id viene rinominato
come o2, e il conteggio viene rinominato come peso.

FROM exhibition_objects eo1, exhibition_objects eo2
Qui la query sta creando due alias (eo1 e eo2) per la tabella exhibition_objects. In pratica, la query sta eseguendo un
auto-join della tabella exhibition_objects con sé stessa.

WHERE eo1.exhibition_id = eo2.exhibition_id
Questa condizione impone che le righe delle due istanze della tabella exhibition_objects devono appartenere allo stesso
exhibition_id.

and eo1.object_id < eo2.object_id
Questa condizione impone che l'object_id di eo1 deve essere minore dell'object_id di eo2. Questo è usato per evitare di
contare due volte la stessa coppia in ordine inverso.

group by eo1.object_id, eo2.object_id
Questa clausola raggruppa i risultati per coppie di object_id. Ogni gruppo rappresenta una coppia unica di oggetti che
appaiono insieme nella stessa esibizione.

order by peso desc
Questa clausola ordina i risultati in ordine decrescente in base al conteggio (peso). Le coppie di oggetti che appaiono
insieme più frequentemente saranno mostrate per prime.



                        SELECT a.*, sum(t.Milliseconds) as totD
                    FROM album a , track t
                    WHERE a.AlbumId = t.AlbumId
                    GROUP by a.AlbumId
                    having totD > %s
Questa query SQL esegue un'aggregazione sui dati delle tabelle album e track per calcolare la durata totale delle tracce
 di ciascun album. Restituisce solo gli album la cui durata totale delle tracce è superiore a un certo valore specificato. Ecco una spiegazione dettagliata delle varie parti della query:

SELECT a.*, sum(t.Milliseconds) as totD
Questa parte della query seleziona tutte le colonne dalla tabella album (indicate da a.*) e calcola la somma dei valori
della colonna Milliseconds dalla tabella track, rinominando questa somma come totD.

FROM album a, track t
Qui la query sta creando due alias (a per la tabella album e t per la tabella track). La query sta unendo le due tabelle.

WHERE a.AlbumId = t.AlbumId
Questa condizione impone che le righe delle due tabelle devono avere lo stesso valore di AlbumId. Questa è la condizione
 di join che lega ogni traccia al suo rispettivo album.

GROUP BY a.AlbumId
Questa clausola raggruppa i risultati per AlbumId. Ogni gruppo rappresenta un singolo album.

HAVING totD > %s
Questa clausola filtra i gruppi risultanti, mantenendo solo quelli per cui la somma delle durate delle tracce (totD) è
maggiore di un valore specificato (indicato come %s, che è un placeholder per un parametro).






                SELECT distinctrow t.AlbumId as a1, t2.AlbumId as a2
                    FROM playlisttrack p , track t , playlisttrack p2 , track t2
                    WHERE p2.PlaylistId = p.PlaylistId
                    and p2.TrackId = t2.TrackId
                    and p.TrackId = t.TrackId
                    and t.AlbumId < t2.AlbumId


Questa query SQL seleziona coppie di album distinti che condividono almeno una traccia in comune in qualsiasi playlist. Ecco una spiegazione dettagliata delle varie parti della query:

SELECT distinctrow t.AlbumId as a1, t2.AlbumId as a2
Questa parte della query seleziona coppie distinte di AlbumId dalla tabella track, rinominandole come a1 e a2. La clausola distinctrow garantisce che ogni coppia di AlbumId appaia una sola volta nel risultato.

FROM playlisttrack p, track t, playlisttrack p2, track t2
Qui la query sta creando quattro alias:
p per la tabella playlisttrack
t per la tabella track
p2 per un'altra istanza della tabella playlisttrack
t2 per un'altra istanza della tabella track

WHERE p2.PlaylistId = p.PlaylistId
Questa condizione impone che le righe delle due istanze della tabella playlisttrack devono appartenere alla stessa
playlist (PlaylistId).

and p2.TrackId = t2.TrackId
Questa condizione impone che l'TrackId nella seconda istanza della tabella playlisttrack deve corrispondere a un TrackId
nella seconda istanza della tabella track.

and p.TrackId = t.TrackId
Questa condizione impone che l'TrackId nella prima istanza della tabella playlisttrack deve corrispondere a un TrackId
nella prima istanza della tabella track.

and t.AlbumId < t2.AlbumId
Questa condizione impone che l'AlbumId del primo track deve essere minore dell'AlbumId del secondo track. Questo serve
a garantire che ogni coppia di album venga considerata una sola volta, evitando duplicati con l'ordine inverso.